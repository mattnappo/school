use std::fs;
use std::path::Path;
use std::process;
use std::thread;
use std::time;

use anyhow::Result;
use redis;
use serde_json as json;

pub mod model;

const DATA_FILE: &'static str = "../parsed/cs_1723076144.json";

fn restart_redis() -> Result<()> {
    Ok(())
}

struct State {
    rdb: redis::Client,
    conn: redis::Connection,
}

impl State {
    pub fn new(reset_rdb: bool) -> Result<Self> {
        if reset_rdb {
            restart_redis()?;
        }

        let client = redis::Client::open("redis://127.0.0.1/")?;
        let conn = client.get_connection()?;
        let mut s = State { rdb: client, conn };

        if reset_rdb {
            s.load_data(DATA_FILE)?;
            s.index()?;
        }

        Ok(s)
    }

    fn index(&mut self) -> Result<()> {
        //redis::pipe().cmd("FT.DROPINDEX").arg("idx:pubs").query(&mut self.conn)?;
        redis::pipe()
            .cmd("FT.CREATE")
            .arg("idx:pubs")
            .arg("ON")
            .arg("JSON")
            .arg("PREFIX")
            .arg("1")
            .arg("pub:")
            .arg("SCHEMA")
            .arg("$.title")
            .arg("AS")
            .arg("title")
            .arg("TEXT")
            .arg("$.abstract")
            .arg("AS")
            .arg("abstract")
            .arg("TEXT")
            .query::<()>(&mut self.conn)?;
        Ok(())
    }

    fn load_data(&mut self, data_file: impl AsRef<Path>) -> Result<()> {
        // Parse dataset from json file (generated by Python)
        let file = fs::read_to_string(data_file)?;
        let pubs: Vec<model::Publication> = json::from_str(&file)?;

        // Load into redis
        pubs.iter()
            .map(|p| -> Result<String> { Ok(json::to_string(p)?) })
            .enumerate()
            .for_each(|(i, r)| {
                r.and_then(|p| -> Result<()> {
                    Ok(redis::pipe()
                        .cmd("JSON.SET")
                        .arg(format!("pub:{i}"))
                        .arg("$")
                        .arg(p)
                        .query(&mut self.conn)?)
                })
                .unwrap();
            });

        Ok(())
    }

    pub fn search(&mut self, query: &str) -> Result<Vec<model::Publication>> {
        let r = redis::pipe()
            .cmd("FT.SEARCH")
            .arg("idx:pubs")
            .arg(format!("(%{query}%|{query}*)"))
            //.arg(query)
            //.arg("RETURN")
            //.arg("0")
            .arg("LIMIT")
            .arg("0")
            .arg("100")
            //.query::<Vec<model::Professor>>(&mut self.conn)?;
            .query::<Vec<model::Professor>>(&mut self.conn)?;

        /*
        let (n, results) = match r {
            redis::Value::Array(a) => {
                let num = match &a[0] {
                    redis::Value::Array(t) => {

                        let n = match &t[0] {
                            redis::Value::Int(i) => i.clone(),
                            _ => unreachable!(),
                        };
                        let res = match &t[2] {
                            redis::Value::BulkString()
                        };
                        (n, res)

                    }

                    _ => unreachable!(),
                };
                println!("num {num:?}");
                123
            }
            _ => unreachable!(),
        };
        */

        dbg!(&r);

        Ok(vec![])
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;

    #[test]
    fn test_start() -> Result<()> {
        let mut state = State::new(false)?;

        state.search("cool")?;

        Ok(())
    }
}
