use std::fs;
use std::path::Path;

use anyhow::Context;
use anyhow::Result;
use redis;
use serde_json as json;

pub mod model;
pub mod server;

// const DATA_FILE: &'static str = "../parsed/cs_1723076144.json";
const DATA_FILE: &'static str = "../parsed/cs_1723089902.json";
const REDIS_SERVER: &str = "redis://127.0.0.1:6379/";

macro_rules! time {
    ($msg:expr, $block:block) => {
        let t0 = std::time::Instant::now();
        $block
        println!(
            "ran '{}' in {} ms",
            $msg,
            (std::time::Instant::now() - t0).as_millis()
        );
    };
}

fn restart_redis() -> Result<()> {
    Ok(())
}

pub struct State {
    conn: redis::Connection,
}

impl State {
    pub fn new(reset_rdb: bool) -> Result<Self> {
        if reset_rdb {
            restart_redis()?;
        }

        let client = redis::Client::open(REDIS_SERVER)?;
        let conn = client.get_connection()?;
        let mut s = State { conn };

        if reset_rdb {
            time!("load data", {
                s.load_data(DATA_FILE)?;
            });
            time!("index data", {
                s.index()?;
            });
        }

        Ok(s)
    }

    fn index(&mut self) -> Result<()> {
        redis::pipe()
            .cmd("FT.CREATE")
            .arg("idx:pubs")
            .arg("ON")
            .arg("JSON")
            .arg("PREFIX")
            .arg("1")
            .arg("pub:")
            .arg("SCHEMA")
            .arg("$.title")
            .arg("AS")
            .arg("title")
            .arg("TEXT")
            .arg("$.abstract")
            .arg("AS")
            .arg("abstract")
            .arg("TEXT")
            .query::<()>(&mut self.conn)?;
        Ok(())
    }

    /// Parse dataset from json file (generated by Python) and load into redis
    fn load_data(&mut self, data_file: impl AsRef<Path>) -> Result<()> {
        json::from_str::<Vec<model::Publication>>(&fs::read_to_string(data_file)?)?
            .iter()
            .map(|p| -> Result<String> { Ok(json::to_string(p)?) })
            .enumerate()
            .try_for_each(|(i, r)| -> Result<()> {
                Ok(redis::pipe()
                    .cmd("JSON.SET")
                    .arg(format!("pub:{i}"))
                    .arg("$")
                    .arg(r?)
                    .query(&mut self.conn)?)
            })
    }

    fn build_query(query: &str) -> String {
        query
            .split_whitespace()
            .enumerate()
            .map(|(i, word)| {
                if i == query.split_whitespace().count() - 1 {
                    format!("(%{word}%|{word}*)")
                } else {
                    word.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join(" ")
    }

    pub fn search(&mut self, query: &str) -> Result<Vec<model::Publication>> {
        Ok(redis::pipe()
            .cmd("FT.SEARCH")
            .arg("idx:pubs")
            .arg(Self::build_query(query))
            .arg("LIMIT")
            .arg("0")
            .arg("1000")
            .query::<Vec<model::Publications>>(&mut self.conn)?
            .into_iter()
            .next()
            .context("failed to parse redis search response")?
            .inner())
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;

    #[test]
    fn test_search1() -> Result<()> {
        let mut state = State::new(false)?;

        let t0 = std::time::Instant::now();
        let search_result = state.search("cache")?;
        assert!(search_result.len() > 0);

        println!(
            "found {} results in {} ns",
            search_result.len(),
            (std::time::Instant::now() - t0).as_nanos()
        );

        let search_result = state.search("asdasdasd")?;
        assert!(search_result.len() == 0);

        Ok(())
    }

    #[test]
    fn test_search2() -> Result<()> {
        let mut state = State::new(false)?;

        let t0 = std::time::Instant::now();
        let search_result = state.search("a")?;
        assert!(search_result.len() > 0);

        println!(
            "found {} results in {} ns",
            search_result.len(),
            (std::time::Instant::now() - t0).as_nanos()
        );

        Ok(())
    }
}
